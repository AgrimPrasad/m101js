<h1>WEEK 2: CRUD</h1><br><div class="notes-container"><div class="row"><h4>BSON</h4><a href="http://bsonspec.org" target="_blank">bsonspec.org</a><ul><li>ISODate</li><li>NumberLong</li></ul><br><h4>Shell</h4><p>Can execute any JavaScript</p><p></p><p>Supports tab complete</p><pre>>help</pre><p>Dislays key binding</p><pre>
>help keys
</pre><p>Print out the database currently in use</p><pre>db</pre><p>Shell interprets people as property of db - named collection</p><pre>db.people.insert(<doc>)</doc></pre><p>Return all the documents in the people collection</p><pre>db.peple.find()</pre><p>Pretty print the output</p><pre>db.people.find().pretty()</pre><p>Returns one document at random from the people collection</p><pre>db.people.findOne()</pre><p>Can pass criteria to findOne (sort of like WHERE in SQL)</p><ul><li>Return documents having "name" property with value of "Jones"</li><li>Query is represented as a document, there is no notion of a separate query language</li></ul><pre>db.people.findOne({"name" : "Jones"})</pre><!-- wip --><!--
Second argument specifies which fields should be returned
Analogous to column portion of SQL SELECT
_id defaults to being visible in results, even if you don't ask for it
<pre>db.people.findOne({"name":"Jones"}, {"name" : true})</pre>

ObjectID construction
PK _id is immutable
Globally unique identifier
- current time
- identifier for machine constructing the object
- process id
- counter (global to process)

Query Operators

<pre>db.scores.find({ score: { $gt : 95 , $lte : 98}, type: "essay" })</pre>
Search scores collection where score > 95 and score <= 98 and type is essay

Can also be applied to strings:
<pre>db.people.find( { name : { $lt : "D" } } )</pre>
Find people whose name is lexicographically less than D

NOTE: Mongo has NO knowledge of locale. Sorts by code units in UTF8. Only correct for POSIX/C locales

All comparison operations are strongly typed

<pre>db.people.find( { profession : { $exists : true }  } )</pre>
Find results in people collection that have the profession property (because not all docs in a collection need to follow the same schema)

<pre>db.people.find( {name : { $type : 2 } } )</pre>
Find people whose name propery is of type String

Mongo supports searching strings by regular expressions using Perl compatible libpcre

<pre>db.people.find( { name : { $regex : "a" } } )</pre>
Find people where name contains the letter a

<pre>db.people.find( { name : { $regex : "e$" } } )</pre>
Find people where name ends with the letter e
NOTE: Regular expressions are not as optimizable as queries using string inequalities.
HOWEVER: Regex's that are optimizable are those starting with caret ^ - begins, followed by non-wildcard, i.e. literal strings and numbers

<pre>db.people.find( { name : { $regex : "^A" } } )</pre>
Find people where name starts with the letter A

OR
<pre>db.people.find( { $or : [ { name : { $regex : "e$" } }, { age : { $exists : true } }] } )</pre>
OR is another example of PREFIX operator. It comes before the arguments
Find people whose name ends in "e" OR where age exists
OR takes as operand, an array of documents to be used as queries

AND
<pre>db.people.find( { $and : [{ name : {$gt : "C"} }, {name: { $regex : "a"} }] } )</pre>
Find people where name is lexicographically greater than C and name contains the letter "a"

<pre>db.people.find( { name : { $gt : "C", $regex : "a" }} )</pre>
$and rarely used because it can be expressed more simply
Can put multiple criteria on name field all together in one doc

Matching is polymorphic over strings and arrays:

<pre>db.accounts.find( {favorites : "pretzels"} )</pre>
Find accounts having favorites = pretzels
OR if favorites is an array, find accounts having pretzels somewhere in the favorites array

Common idiom in Mongo: Embed an array of strings in a document, then query by string value

BUT there is no recursion, will not search if favorites array contains embedded arrays

db.accounts.find( {favorites : { $all : ["pretzels", "beer"] }} )
$all matches any document that has all the specified elements. i.e. ["pretzels", "beer"] should be a subset of favorites in matching documents. Order doesn't matter

OR
db.accounts.find( { name : { $in : ["Howard", "John"] } } );
Return accounts where name is either Howard or John

Querying on embedded documents

Given this data:
db.users.insert( { name : "richard", email : { work : "richard@10gen.com", personal : "kreuter@example.com"} } );

You could try to find by exact match, BUT order of fields is important because Mongo will search byte by byte.

What if you only know the work email address?

DOT NOTATION
- allows you to reach inside embedded documents, looking for a specific field
db.users.find( { "email.work" : "richard@10gen.com" } );

Cursors
cur = db.people.find(); null;
- cur is a variable holding on to a cursor object
cur.hasNext();  // returns true if there's another document to visit
cur.next(); // returns next document in the collection
- can control programmatically how you step through each doc, eg:
while (cur.hasNext()) pringjson(cur.next()));

Cursor Methods
cur.limit(5); null; // return only 5 documents
- limit also returns the cursor, to avoid eagerly printing out the docs, tack on 'null;'

cur.sort( { name : -1 } ); null;

Can combine by chaining together
cur.sort( { name : -1 } ).limit(3); null;

- sort and limit modify information that's transmitted to database
- cannot apply these methods after you've started retrieving documents, because sort & limit are processed inside the database engine, server side, NOT in client side memory

cur.sort().limit(3).skip(2); null;
- skip the first two

Counting Documents
db.scores.count( {type : "exam"} );

Updating Documents

4 Types of Updates
- Wholesale replacement of doc
- Manipulate individual fields within a doc
- Perform upsert (update or insert)
- Update multiple documents

db.people.update( { name : "Smith }, { name : "Thompson", salary : 50000 } ); // DANGEROUS - replacing approach
- updates take at least 2 args:
a) query (similar to find)
b) document - everything in this doc will replace whatever is in current document having name Smith

Safer Update: $set
db.people.update( { name : "Alice" }, { $set : { age : 30 } } );
- find the document having name Alice and set the age to 30
- if there is no age field, one will be created

Update: $inc
db.people.update( { name : "Alice" }, { $inc : { age : 1 } } );
- find document having name Alice and increment age field by 1
- if age field doesn't exist, $inc will create a new field, having as its value, the increment value (1 in this case)

Remove Field: $unset
db.people.update( { name : "Jones" }, { $unset : { profession : 1 } } );
- value is arbitrary, any value will work
- remove the field profession and its value from the document in people collection having name Jones

Array Manipulation
db.arrays.insert( { _id : 0, a : [1, 2, 3, 4] } );
db.arrays.update( { _id : 0 }, { $set : { "a.2" : 5 } } );
- array field followed by dot, followed by decimal index (2 === 3rd element): update 3rd element to be 5

Add element to end of array
db.arrays.update( { _id : 0 }, { $push : { a : 6 } } );
- extends array by adding new element to it

Remove right-most element
db.arrays.update( { _id : 0 }, { $pop : { a : 1 } } );

Remove left-most element
db.arrays.update( { _id : 0 }, { $pop : { a : -1 } } );

Add multiple elements
db.arrays.update( { _id : 0 }, { $pushAll : { a : [ 7, 8, 9 ] } } );

Remove an element from any position
db.arrays.update( { _id : 0 }, { $pull : { a : 5 } } );
- removes value 5 from array

Remove multiple elements
db.arrays.update( { _id : 0 }, { $pullAll : { a : [ 2, 4, 8 ] } } );

Idempotent update
db.arrays.update( { _id : 0 }, { $addToSet : { a : 5} } );
- adds 5 if its not already there, otherwise, does nothing

UPSERT
- if use $set but document doesn't exist, then update will have no effect
- common use case: update existing doc OR if it doesn't exist, create new
db.people.update({ name : "George" }, { $set : { age: 40 } }, { upsert : true});
- update people doc having name George setting age to 40 OR if no such doc, create doc with name George and age 40

UPSERT Edge case
If don't provide enough information in query
db.people.update( { age : { $gt : 50 } }, { $set : { name : "William"} }, { upsert : true} );
"Age greater than 50" is not specific enough to say which doc to update. In this case, will create a new doc having name William but age will not be populated

Multi Update
db.people.update( {} , { $set : { title : "Dr" } }, { multi: true } );
- empty selector matches every doc in the collection (also true for find)
BUT by default, mongo will only update the first doc it finds UNLESS you also specify multi : true
(this is different than default SQL UPDATE behaviour which would update all)

Write Concurrency Implications
Inside mongodb, there is single thread for each operation that's being executed, however, this thread may yield (i.e. pause) to allow other operations to proceed.
Write operations, even if they affect multiple documents ARE NOT ISOLATED TRANSACTIONS.
Eg: If an update affects 10 docs, could write 3, yield/pause to allow something else to happen, write 3 more, pause, etc.
Individual document write operation is guaranteed to be atomic, i.e. no other thread will see the document half updated

Removing Data
- 3 different options

db.people.remove( {} );
- remove works similar to find
- if specify no args, all docs in collection will be removed one by one

db.people.remove( { name : "Alice" } );
- remove doc in people collection having name = Alice

db.people.remove( { name : { $gt : "M" } } );
- remove all documents having name greater than capital M

db.people.drop();
- remove the entire people collection in a single pass
- faster than removing docs one by one

DROP vs REMOVE
- if collection has metadata associated with it (eg: indicies), this is also discarded on drop, but maintained on remove
- remove can affect arbitrary number of documents, just like with multi update, this is NOT atomic transaction
- eg: if remove operation affects 10 documents, a concurrent read or write operation may see this collection part-way through the remove operation
- but each INDIVIDUAL remove is atomic wrt to concurrent readers/writers

ERRORS
- interactive shell always checks to see if last operation succeeded or failed, and displays error message if failure

Duplicate Key Error
db.people.insert( { _id : "Smith", age : 30 } );
db.people.insert( { _id : "Smith", age : 30 } );
E11000 duplicate key error index

db.runCommand( { getLastError : 1 } );
- returns outcome of last operation on current connection
- result is a document, if there was an error, doc will have "err" field with error message
- if last write operation succeeded, "err" will be null
- for multi-update, getLastError returns info like docs already existed, and how many were updated
- for upsert, getLastError will indicate the doc that it upserted
- for remove, getLasteError indicates how many docs were removed

Node.js Driver & CRUD

Import json data
mongoimport -d course -c grades grades.json

Importing csv data
--type csv
--headerline tells mongo that first line in csv is header record, will set all the field names accordingly

Cursor
Definition is synchronous
when call .each or .toArray, then it sends request to db for docs and mongod responds
response is a batch of documents, not the whole thing at once

Example of query operator (to do range)
var query = { 'student' : 'Joe', 'grade' : { '$gt' : 80, '$lt' : 95 } };
 db.collection('grades').find(query).each(function(err, doc) {...});
Find all docs where student is Joe and grade is between 80 and 95

Order of Operations
1. Sort
2. Skip
3. Limit
    var grades = db.collection('grades');
    var cursor = grades.find({});
    cursor.skip(1);
    cursor.limit(4);
    cursor.sort('grade', 1);
- no matter what order you specify in code, driver re-orders operations

cursor.sort([['grade', 1], ['student', -1]]);
- sort first by grade, then by student DESCENDING
- order of sort criteria within array is important

   var options = { 'skip' : 1,
                   'limit' : 4,
                   'sort' : [['grade', 1], ['student', -1]] };
var cursor = grades.find({}, {}, options);
- first arg is query criteria (blank means find all)
- second arg is projection (i.e. which fields from doc to return, blank means return all)
- third arg is options (sort, skip, limit)

Save
db.collection('grades').save(doc, function(err, saved)...
- checks to see if doc has _id, if not, will insert a new doc, if yes, will assume you meant to do an upsert

findAndModify
- atomically finds and updates the doc
- only finds and modifies a SINGLE document

    var query = { 'name' : 'comments' };
    var sort = [];
    var operator = { '$inc' : { 'counter' : 1 } };
    var options = { 'new' : true };
    db.collection('counters').findAndModify(query, sort, operator, options, function(err, doc)...
- query: search criteria
- sort (could be []) - required in case query is not specific enough and returns multiple docs
- operator: update operation to perform
- options: new:true means return the doc after its been modified, false would return doc before it was modified
--></div></div>