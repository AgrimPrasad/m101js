<div class="notes-container"><div class="row"><h1>Performance</h1><hr><div class="notes-info"><h2>Index</h2><ul><li>Single most important factor in performance</li><li>Performance driven by: Is the index going to be used by this query?</li><li>Documents could be anywhere on disk.</li><li>By default, database must scan through entire collection to find data</li><li><em>Collection Scan</em> is death to performance</li><li>An <strong>index</strong> is an ordered list of keys, order of keys is important</li><li>Each entry in index points to actual document in collection</li><li>In order for database to use index, query must give it by left-most set of index keys</li><li>Sort will also use an index to sort values</li></ul></div><div class="notes-attention"><h3>Considerations</h3><ul><li>On every insert, index must be updated</li><li>Having index makes reads faster, but writes slower</li><li>Index takes up space on disk</li><li>Create an index on ways you're most likely to query the collection</li></ul></div><h2>Creating Indexes</h2><p>Create index on <code>student_id</code> and make it ascending.<br>Could take some time if collection already exists and is very large</p><pre>$ db.students.ensureIndex( {  student_id:1 } )</pre><p>Create <strong>compound index</strong> on <code>student_id</code> and <code>class</code> descending.<br>Ascending/descending doesn't make any difference to find, but does matter for sort</p><pre>$ db.students.ensureIndex( { student_id:1, class:-1 } )</pre><h2>Discovering Indexes</h2><p>Show all indexes in the current database.<br>Note that every collection has by default, index on <code>_id</code></p><pre>$ db.system.indexes.find();</pre><p>Show all indexes on a collection</p><pre>$ db.students.getIndexes();</pre><p>To drop an index, must pass name <em>exactly</em> as when created it</p><pre>$ db.students.dropIndex({'students_id':1})</pre><h2>Multikey Indexes</h2><p>Can have a key that holds an array, for example</p><pre>
      {
        tags : ["cycling, "tennis", "football"],
        categories : ["sports", "hobbies"]
      }
    </pre><p>If you create an index on tags, mongo will create a <strong>multikey index</strong>, will get an index point for <em>every</em> item in the array.<br>A multikey index cannot contain multiple array keys, insert will fail on <code>parallel arrays</code> error.<br>Index creation is <em>dynamic</em>, doesn't know at creation time that you might put more arrays for keys.</p><h2>Index Create Option</h2><dl class="dl-horizontal"><dt>Unique Index</dt><dd>Enforces that each key value must be unique</dd></dl><p>Will get duplicate key error if try to insert more than oen of the same thing in stuff collection</p><pre>
      $ db.stuff.ensureIndex({'thing':1}, {unique:true})
      $ db.stuff.insert('thing':'apple');   // ok
      $ db.stuff.insert('thing':'pear');    // ok
      $ db.stuff.insert('thing':'apple');   // duplicate key error
    </pre><p>_id index is unique by default, even though listing index doesn't show unique: true</p><h2>Removing Duplicates when creating Unique Indexes</h2><pre>$ db.stuff.ensureIndex({'thing':1}, {unique:true, dropDups:true});</pre><div class="notes-attention"><h3>Careful with dropDups Option!</h3><ul><li>If more than one document is found with the same key, will remove all but one</li><li>No way to control which documents will be removed</li><li>Deleted documents cannot be retrieved again</li></ul></div><h2>Sparse Index</h2><ul><li>Multiple documents could be missingthe index key</li><li>Database considers unspecified values to be null</li><li>But unique means eachkey value can only be in index once (including null)</li><li>Sparse index solves this problem by only indexing documents that have a key set for the key being indexed</li><li>Doesn't have to be unique to be sparse</li></ul><pre>$ db.products.ensureIndex({size:1}, {unique: true, sparse:true})</pre><div class="notes-attention"><h3>Side Effects</h3><p>if use this kind of index to sort by, for example <code>size</code>, will only return the docs that have size populated, other docs will be left out</p></div><h2>Index Creation: Background</h2><p>By default, index is created in the foreground, which blocks all other writers, this is the fastest option.<br>If specify <code>background:true</code> option, index creation could be up to 5 times slower, but will not block writers.</p><h2>Using Explain</h2><p>Appending <code>.explain()</code> to query will return explanation of what database did to get result, instead of returning result itself.</p><pre>$ db.foo.find({c:1}).explain()</pre><dl class="dl-horizontal"><dt>"cursor" : "BasicCursor</dt><dd>No index was used. BasicCursor is name of cursor that scans <em>all</em> documents in a collection</dd><dt>"cursor" : "BtreeCursor a_1_b_1_c_1"</dt><dd>Index on keys a,b,c was used</dd><dt>"millis" : 5</dt><dd>Number of milliseconds required to execute the query</dd><dt>"isMultiKey" : false</dt><dd>None of the index keys are multi-key</dd><dt>"n" : 1</dt><dd>Number of document returned</dd><dt>"nscannedObjects" : 1</dt><dd>Number of documents scanned to find results</dd><dt>"nscanned" : 1</dt><dd>Number of index entries mongo had to look at to find results</dd><dt>"indexOnly" : false</dt><dd>Indicates whether query could be satisfied with just the index.</dd></dl><div class="notes-info"><p>When "indexOnly" is true, this is referred to as a <strong>Covered Index</strong>, meaning mongo doesn't have to go to collection at all, can get all the data it needs from the index alone.</p><p>Its possible that mongo can't use the index to find, but can for sort</p></div><h2>When is an index used?</h2><p>Database can only use one index for a given query.<br>If multiple applicable indexes exist, mongo will run all plans in parallel, and "remember" the first one that returns. That gets flagged as the fastest and will be used next time.<br>Every 100 or so queries, mongo will run another experiment to choose potentially a different index.<br>find, findOne, update, remove can all benefit from indexes.</p><h2>How large is an index?</h2><p>To achieve performance benefits, index should be entirely contained in memory.</p><pre>
      $ db.students.stats()             // get collection info
      $ db.students.totalIndexSize()    // get index size
    </pre><h2>Index Cardinality</h2><p>Measure of how many index points are present for each different type of index that mongo supports</p><dl class="dl-horizontal"><dt>Regular</dt><dd>One to one, for every key, there is an index poit, if there is no key, get entry for null point</dd><dt>Sparse</dt><dd>Could have fewer index points than documents, because when document is missing the key being indexed, a sparse index does not keep a point to null</dd><dt>Multikey</dt><dd>Could have more index points than documents, because an index point will be created for each item in the array, for a given document</dd></dl><div class="notes-attention"><p>When a document moves on disk (eg: if doc was updated and now can't fit in that spot on disk), every single index point that points to it needs to be updated</p></div><h2>Index Selectivity</h2><p>When designing indexes, want it to be as "selective" as possible (similar to relational world)</p><p>For example, if have a collection of logging operation codes and timestamp, makes more sense to index first by timestamp, then opcode. Because opcode only eliminates about 1/5 of the data, whereas timestamp could have millions of per opcode.</p><h2>Hinting an Index</h2></div><!-- End row --></div><!-- End notes-container -->