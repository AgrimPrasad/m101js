<div class="notes-container"><div class="row"><h1>Performance</h1><hr><div class="notes-info"><h2>Index</h2><ul><li>Single most important factor in performance</li><li>Performance driven by: Is the index going to be used by this query?</li><li>Documents could be anywhere on disk.</li><li>By default, database must scan through entire collection to find data</li><li><em>Collection Scan</em> is death to performance</li><li>An <strong>index</strong> is an ordered list of keys, order of keys is important</li><li>Each entry in index points to actual document in collection</li><li>In order for database to use index, query must give it by left-most set of index keys</li><li>Sort will also use an index to sort values</li></ul></div><div class="notes-attention"><h3>Considerations</h3><ul><li>On every insert, index must be updated</li><li>Having index makes reads faster, but writes slower</li><li>Index takes up space on disk</li><li>Create an index on ways you're most likely to query the collection</li></ul></div><h2>Creating Indexes</h2><p>Create index on <code>student_id</code> and make it ascending.<br>Could take some time if collection already exists and is very large</p><pre>&gt; db.students.ensureIndex( {  student_id:1 } )</pre><p>Create <strong>compound index</strong> on <code>student_id</code> and <code>class</code> descending.<br>Ascending/descending doesn't make any difference to find, but does matter for sort</p><pre>&gt; db.students.ensureIndex( { student_id:1, class:-1 } )</pre><h2>Discovering Indexes</h2><p>Show all indexes in the current database.<br>Note that every collection has by default, index on <code>_id</code></p><pre>&gt; db.system.indexes.find();</pre><p>Show all indexes on a collection</p><pre>&gt; db.students.getIndexes();</pre><p>To drop an index, must pass name <em>exactly</em> as when created it</p><pre>&gt; db.students.dropIndex({'students_id':1})</pre><h2>Multikey Indexes</h2><p>Can have a key that holds an array, for example</p><pre>
      {
        tags : ["cycling, "tennis", "football"],
        categories : ["sports", "hobbies"]
      }
    </pre><p>If you create an index on tags, mongo will create a <strong>multikey index</strong>, will get an index point for <em>every</em> item in the array.<br>A multikey index cannot contain multiple array keys, insert will fail on <code>parallel arrays</code> error.<br>Index creation is <em>dynamic</em>, doesn't know at creation time that you might put more arrays for keys.</p><h2>Index Create Option</h2><dl class="dl-horizontal"><dt>Unique Index</dt><dd>Enforces that each key value must be unique</dd></dl><p>Will get duplicate key error if try to insert more than oen of the same thing in stuff collection</p><pre>
      &gt; db.stuff.ensureIndex({'thing':1}, {unique:true})
      &gt; db.stuff.insert('thing':'apple');   // ok
      &gt; db.stuff.insert('thing':'pear');    // ok
      &gt; db.stuff.insert('thing':'apple');   // duplicate key error
    </pre><p>_id index is unique by default, even though listing index doesn't show unique: true</p><h2>Removing Duplicates when creating Unique Indexes</h2><pre>&gt; db.stuff.ensureIndex({'thing':1}, {unique:true, dropDups:true});</pre><div class="notes-attention"><h3>Careful with dropDups Option!</h3><ul><li>If more than one document is found with the same key, will remove all but one</li><li>No way to control which documents will be removed</li><li>Deleted documents cannot be retrieved again</li></ul></div><h2>Sparse Index</h2><ul><li>Multiple documents could be missingthe index key</li><li>Database considers unspecified values to be null</li><li>But unique means eachkey value can only be in index once (including null)</li><li>Sparse index solves this problem by only indexing documents that have a key set for the key being indexed</li><li>Doesn't have to be unique to be sparse</li></ul><pre>&gt; db.products.ensureIndex({size:1}, {unique: true, sparse:true})</pre><div class="notes-attention"><h3>Side Effects</h3><p>if use this kind of index to sort by, for example <code>size</code>, will only return the docs that have size populated, other docs will be left out</p></div><h2>Index Creation: Background</h2><p>By default, index is created in the foreground, which blocks all other writers, this is the fastest option.<br>If specify <code>background:true</code> option, index creation could be up to 5 times slower, but will not block writers.</p><h2>Using Explain</h2><p>Appending <code>.explain()</code> to query will return explanation of what database did to get result, instead of returning result itself.</p><pre>&gt; db.foo.find({c:1}).explain()</pre><dl class="dl-horizontal"><dt>"cursor" : "BasicCursor</dt><dd>No index was used. BasicCursor is name of cursor that scans <em>all</em> documents in a collection</dd><dt>"cursor" : "BtreeCursor a_1_b_1_c_1"</dt><dd>Index on keys a,b,c was used</dd><dt>"millis" : 5</dt><dd>Number of milliseconds required to execute the query</dd><dt>"isMultiKey" : false</dt><dd>None of the index keys are multi-key</dd><dt>"n" : 1</dt><dd>Number of document returned</dd><dt>"nscannedObjects" : 1</dt><dd>Number of documents scanned to find results</dd><dt>"nscanned" : 1</dt><dd>Number of index entries mongo had to look at to find results</dd><dt>"indexOnly" : false</dt><dd>Indicates whether query could be satisfied with just the index.</dd></dl><div class="notes-info"><p>When "indexOnly" is true, this is referred to as a <strong>Covered Index</strong>, meaning mongo doesn't have to go to collection at all, can get all the data it needs from the index alone.</p><p>Its possible that mongo can't use the index to find, but can for sort</p></div><h2>When is an index used?</h2><p>Database can only use one index for a given query.<br>If multiple applicable indexes exist, mongo will run all plans in parallel, and "remember" the first one that returns. That gets flagged as the fastest and will be used next time.<br>Every 100 or so queries, mongo will run another experiment to choose potentially a different index.<br>find, findOne, update, remove can all benefit from indexes.</p><h2>How large is an index?</h2><p>To achieve performance benefits, index should be entirely contained in memory.</p><pre>
      &gt; db.students.stats()             // get collection info
      &gt; db.students.totalIndexSize()    // get index size
    </pre><h2>Index Cardinality</h2><p>Measure of how many index points are present for each different type of index that mongo supports</p><dl class="dl-horizontal"><dt>Regular</dt><dd>One to one, for every key, there is an index poit, if there is no key, get entry for null point</dd><dt>Sparse</dt><dd>Could have fewer index points than documents, because when document is missing the key being indexed, a sparse index does not keep a point to null</dd><dt>Multikey</dt><dd>Could have more index points than documents, because an index point will be created for each item in the array, for a given document</dd></dl><div class="notes-attention"><p>When a document moves on disk (eg: if doc was updated and now can't fit in that spot on disk), every single index point that points to it needs to be updated</p></div><h2>Index Selectivity</h2><p>When designing indexes, want it to be as "selective" as possible (similar to relational world)</p><p>For example, if have a collection of logging operation codes and timestamp, makes more sense to index first by timestamp, then opcode. Because opcode only eliminates about 1/5 of the data, whereas timestamp could have millions of per opcode.</p><h2>Hinting an Index</h2><p>Normally mongo makes its own decisions what index to use, but you can also tell it which to use</p><pre>&gt; db.foo.find({a:"hello"}).hint({a:1,b:1,c:1})</pre><p>You can also tell mongo not to use an index at all</p><pre>&gt; db.foo.find({a:"hello"}).hint({$natural:1})</pre><h3>Hinting in Node.js</h3><p>Explain can also be used in the driver</p><pre>
      var cursor = db.collection('coll').find({'x':2}); // defines query
      cursor.explain(function(err, explain_output) {    // runs query
        // do something with the output
      });
    </pre><div class="notes-attention"><h3>Careful with Hint</h3><p>If you hint an index, but query doesn't have any key in that index, performance could be worse because mongo will attempt to use the index, but doesn't help so it still has to scan the entire collection.<br><strong>Recommendation:</strong> Run explain with hint first, to verify that index you intended will actually be used.</p></div><h2>Efficiency of index use</h2><p>Just because an index is being used, doesn't mean its being used efficiently.<ul><li>$gt, $lt may use the index, but still require inspection of a lot of documents.</li><li>$ne, 'does not exist', all negative operators are inefficient with index use.</li><li>$regex, if don't give something that is stemmed on left part of index, will still be slow.</li><ul><li>/abcd/ still has to scan all docs</li><li>/^abcd/ can use index efficiently because you're saying "starts with..."</li></ul></ul>Consider collection with 1000's of students, but not that many classes.<pre>&gt; db.students.find({student_id:{$gt:500}, class_id:20)</pre>With two different indexes available:<ol><li>Index on student_id,class_id</li><li>index on just class_id</li></ol>Mongo may choose to use the first index, but won't be efficient because $gt:500 only rules out about half the records, then mongo still needs to manually scan the rest of the docs.<br>It would be more efficient would be to hint mongo to use the class_id index, because there's not that many classes, so mongo can use the index to find that, then only needs to manually scan a smaller set of students to find those with id &gt; 500, within matches of class_id=1.<pre>&gt; db.students.find({student_id:{$gt:500}, class_id:20).hint({'class_id':1})</pre></p><h2>Geospatial Indexes (2D)</h2><p>Allow you to find things based on location.<br>Consider 2D plane of x and y co-ordinates, with a few business (represented as small circles), scatterred about, and a Person (P) located at a particular co-ordinate x,y. How to find what's closest to that person?</p><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><line id="horizontal" x1="0" y1="100" x2="200" y2="100" style="stroke:#006600"></line><line id="vertical" x1="100" y1="200" x2="100" y2="0" style="stroke:#006600"></line><circle id="nw" cx="50" cy="80" r="3" style="stroke:#292A29; fill:#292A29"></circle><circle id="ne" cx="170" cy="30" r="3" style="stroke:#292A29; fill:#292A29"></circle><circle id="sw" cx="20" cy="120" r="3" style="stroke:#292A29; fill:#292A29"></circle><circle id="se" cx="138" cy="155" r="3" style="stroke:#292A29; fill:#292A29"></circle><text id="person-ne" x="118" y="60" style="fill: #EB0CAC; stroke: none; font-size: 15px">P</text><text id="person-coord" x="129" y="61" style="fill: #EB0CAC; stroke: none; font-size: 13px">(x,y)</text></svg></div><!-- End row --></div><!-- End notes-container -->